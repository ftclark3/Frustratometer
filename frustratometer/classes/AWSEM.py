import numpy as np
from ..utils import _path
from .. import frustration
from .Frustratometer import Frustratometer
from .Gamma import Gamma
from pydantic import BaseModel, Field, ConfigDict
from pydantic.types import Path
from typing import List,Optional,Union

__all__ = ['AWSEM']

class AWSEMParameters(BaseModel):
    model_config = ConfigDict(extra='ignore', arbitrary_types_allowed=True)
    """Default parameters for AWSEM energy calculations."""
    k_contact: float = Field(4.184, description="Coefficient for contact potential. (kJ/mol)")
    
    #Density
    eta: float = Field(5.0, description="Sharpness of the distance-based switching function (Angstrom^-1).")
    rho_0: float = Field(2.6, description="Density cutoff defining buried residues.")
    min_sequence_separation_rho: Optional[int] = Field(2, description="Minimum sequence separation for density calculation.")

    #Burial potential
    burial_in_context: Optional[bool] = Field(True, description="For substructure objects, this may include interactions from remainder of protein in burial term.")
    burial_kappa: float = Field(4.0, description="Sharpness of the density-based switching function for the burial potential wells")
    burial_ro_min: List[float] = Field([0.0, 3.0, 6.0], description="Minimum radii for burial potential wells. (Angstrom)")
    burial_ro_max: List[float] = Field([3.0, 6.0, 9.0], description="Maximum radii for burial potential wells. (Angstrom)")
    
    #Direct contacts
    min_sequence_separation_contact: Optional[int] = Field(0, description="Minimum sequence separation for contact calculation.")
    distance_cutoff_contact: Optional[float] = Field(9.5, description="Distance cutoff for contact calculation. (Angstrom)")
    min_contact_distance: Optional[float] = Field(3.5, description = "Minimum distance for contact to be considered in frustration matrix and tcl script")
    r_min: float = Field(4.5, description="Minimum distance for direct contact potential. (Angstrom)")
    r_max: float = Field(6.5, description="Maximum distance for direct contact potential. (Angstrom)")
    
    #Mediated contacts
    gamma: Union[Path,Gamma] = Field(_path/'data'/'AWSEM_2015.json', description="File or Gamma object containing the Gamma values")
    r_minII: float = Field(6.5, description="Minimum distance for mediated contact potential. (Angstrom)")
    r_maxII: float = Field(9.5, description="Maximum distance for mediated contact potential. (Angstrom)")
    eta_sigma: float = Field(7.0, description="Sharpness of the density-based switching function between protein-mediated and water-mediated contacts.")
    

    #Membrane
    membrane_gamma: Union[Path,Gamma] = Field(_path/'data'/'AWSEM_membrane_2015.json', description="File or Gamma object containing the membrane Gamma values (for membrane proteins)")
    eta_switching: int = Field(10, description="Switching distance for the membrane switching function")

    #Electrostatics
    min_sequence_separation_electrostatics: Optional[int] = Field(1, description="Minimum sequence separation for electrostatics calculation.")
    k_electrostatics: float = Field(17.3636, description="Coefficient for electrostatic interactions. (kJ/mol)")
    electrostatics_screening_length: float = Field(10, description="Screening length for electrostatic interactions. (Angstrom)")

class AWSEM(Frustratometer):
    #Mapping to DCA
    q = 20
    aa_map_awsem_list = [0, 0, 4, 3, 6, 13, 7, 8, 9, 11, 10, 12, 2, 14, 5, 1, 15, 16, 19, 17, 18] #A gap has no energy
    aa_map_awsem_x, aa_map_awsem_y = np.meshgrid(aa_map_awsem_list, aa_map_awsem_list, indexing='ij')
    
    def __init__(self, 
                 pdb_structure: object,
                 sequence: str =None,
                 expose_indicator_functions: bool=False,
                 stats_by_chain: bool=False,
                 **parameters)->object:
        """
        Generate AWSEM object

        Parameters
        ----------
        pdb_structure : object
            Structure object generated by Structure class
        sequence :  str
            The amino acid sequence of the protein. The sequence is assumed to be in one-letter code. 
        expose_indicator_functions: bool
            If set to True, indicator functions of the contact and burial energy terms can be accessed by user.
        stats_by_chain: bool
            If set to True, aa_freq, distance distributions, and local density distributions will be
            calculated separately for each chain, potentially resulting in a different misfolded mean and variance
            for each chains
        
        Returns
        -------
        AWSEM object
        """

        #Set attributes
        p = AWSEMParameters(**parameters)
        ############################################################
        # probably should delete this once the min contact distance is integrated into the compute_mask function
        self.min_contact_distance = p.min_contact_distance
        ############################################################
        if p.min_sequence_separation_contact is None:
            p.min_sequence_separation_contact = 1
        if p.min_sequence_separation_rho is None:
            p.min_sequence_separation_rho = 1
        if p.min_sequence_separation_electrostatics is None:
            p.min_sequence_separation_electrostatics = 1

        for field, value in p:
            setattr(self, field, value)
        
        #Gamma parameters
        if isinstance(p.gamma, Gamma):
            gamma = p.gamma
        elif isinstance(p.gamma, Path):
            gamma = Gamma(p.gamma)
        else:
            raise ValueError("Gamma parameter must be a path or a Gamma object.")
                
        self.gamma=gamma
        self.burial_gamma = gamma['Burial'].T
        self.direct_gamma = gamma['Direct'][0]
        self.protein_gamma = gamma['Protein'][0]
        self.water_gamma = gamma['Water'][0]
        self.burial_in_context=p.burial_in_context

        #Structure details
        self.full_to_aligned_index_dict=pdb_structure.full_to_aligned_index_dict
        if sequence is None:
            self.sequence=pdb_structure.sequence
        else:
            self.sequence=sequence
        self.structure=pdb_structure.structure
        self.chain=pdb_structure.chain # unless we further edit the Structure class, this will be a string like "AB" or "A B"
        if type(self.chain) == str: # going forward, it's easiest if we convert this string into a list like ["A","B"]
            self.chain = [id for id in self.chain if id != " "]  
        self.stats_by_chain = stats_by_chain
        if self.stats_by_chain and self.burial_in_context:
            raise NotImplementedError("burial in context not yet supported for chainwise mean and variance calculations")                             
        self.start_mask = pdb_structure.start_mask # list equal to the length of the protein where each index that is the same
                                                   # as a chain start index is 1, and all other indices are 0
        self.pdb_file=pdb_structure.pdb_file
        self.init_index_shift=pdb_structure.init_index_shift
        self.distance_matrix=pdb_structure.distance_matrix
        self.full_pdb_distance_matrix=pdb_structure.full_pdb_distance_matrix
        selection_CB = self.structure.select('name CB or (resname GLY IGL and name CA)')

        resid = selection_CB.getResindices()
        self.resid=resid
        self.N=len(self.resid)
        assert self.N == len(self.sequence), f"N: {self.N}, resids: {self.resid}\nlen(self.sequence):{len(self.sequence)},{self.sequence}\nThe pdb is incomplete. Try setting 'repair_pdb=True' when constructing the Structure object.\n{selection_CB.getResnames()}"

        if self.burial_in_context==True:
            selected_matrix=self.full_pdb_distance_matrix
        else:
            selected_matrix=self.distance_matrix
        sequence_mask_rho = frustration.compute_mask(selected_matrix, 
                                                     maximum_contact_distance=None, 
                                                     minimum_sequence_separation = p.min_sequence_separation_rho,
                                                     start_mask = self.start_mask)
        sequence_mask_contact = frustration.compute_mask(self.distance_matrix, 
                                                     maximum_contact_distance=p.distance_cutoff_contact, 
                                                     minimum_sequence_separation = p.min_sequence_separation_contact,
                                                     start_mask = self.start_mask)
        
        self._decoy_fluctuation = {}
        self.minimally_frustrated_threshold=.78

        # Calculate rho
        rho = 0.25 
        rho *= (1 + np.tanh(p.eta * (selected_matrix- p.r_min)))
        rho *= (1 + np.tanh(p.eta * (p.r_max - selected_matrix)))
        rho *= sequence_mask_rho
        self.rho=rho
        
        #Calculate sigma water
        rho_r = (rho).sum(axis=1)
        if self.full_pdb_distance_matrix.shape!=self.distance_matrix.shape:
            if self.burial_in_context==True:
                self.init_index_shift=pdb_structure.init_index_shift
                self.fin_index_shift=pdb_structure.fin_index_shift
                rho_r=rho_r[self.init_index_shift:self.fin_index_shift]
        self.rho_r=rho_r
        rho_b = np.expand_dims(rho_r, 1)
        rho1 = np.expand_dims(rho_r, 0)
        rho2 = np.expand_dims(rho_r, 1)
        sigma_water = 0.25 * (1 - np.tanh(p.eta_sigma * (rho1 - p.rho_0))) * (1 - np.tanh(p.eta_sigma * (rho2 - p.rho_0)))
        sigma_protein = 1 - sigma_water

        #Calculate theta and indicators
        theta = 0.25 * (1 + np.tanh(p.eta * (self.distance_matrix - p.r_min))) * (1 + np.tanh(p.eta * (p.r_max - self.distance_matrix)))
        thetaII = 0.25 * (1 + np.tanh(p.eta * (self.distance_matrix - p.r_minII))) * (1 + np.tanh(p.eta * (p.r_maxII - self.distance_matrix)))
        burial_indicator = np.tanh(p.burial_kappa * (rho_b - p.burial_ro_min)) + np.tanh(p.burial_kappa * (p.burial_ro_max - rho_b))
        direct_indicator = theta[:, :, np.newaxis, np.newaxis]
        water_indicator = thetaII[:, :, np.newaxis, np.newaxis] * sigma_water[:, :, np.newaxis, np.newaxis]
        protein_indicator = thetaII[:, :, np.newaxis, np.newaxis] * sigma_protein[:, :, np.newaxis, np.newaxis]
        
        if expose_indicator_functions:
            self.indicators=[]
            self.indicators.append(burial_indicator[:,0])
            self.indicators.append(burial_indicator[:,1])
            self.indicators.append(burial_indicator[:,2])
            
            self.indicators.append(direct_indicator[:,:,0,0]*sequence_mask_contact)
            self.indicators.append(protein_indicator[:,:,0,0]*sequence_mask_contact)
            self.indicators.append(water_indicator[:,:,0,0]*sequence_mask_contact)
            
            self.gamma_array=[]
            temp_burial_gamma=self.burial_gamma[self.aa_map_awsem_list]
            temp_burial_gamma[0]=0
            temp_burial_gamma *= -0.5 * p.k_contact
            self.gamma_array.append(temp_burial_gamma[:,0])
            self.gamma_array.append(temp_burial_gamma[:,1])
            self.gamma_array.append(temp_burial_gamma[:,2])

            for contact_gamma in [self.direct_gamma, self.protein_gamma, self.water_gamma]:
                temp_gamma = contact_gamma[self.aa_map_awsem_x, self.aa_map_awsem_y].copy()
                temp_gamma[0, :] = 0
                temp_gamma[:, 0] = 0
                temp_gamma *= -0.5 * self.k_contact
                self.gamma_array.append(temp_gamma)

            self.burial_indicator = burial_indicator
            self.direct_indicator = direct_indicator
            self.water_indicator = water_indicator
            self.protein_indicator = protein_indicator
            

        J_index = np.meshgrid(range(self.N), range(self.N), range(self.q), range(self.q), indexing='ij', sparse=False)
        h_index = np.meshgrid(range(self.N), range(self.q), indexing='ij', sparse=False)

        #Burial energy
        burial_energy = 0.5 * p.k_contact * self.burial_gamma[h_index[1]] * burial_indicator[:, np.newaxis, :]
        self.burial_energy = burial_energy

        #Contact energy
        direct = direct_indicator * self.direct_gamma[J_index[2], J_index[3]]
        water_mediated = water_indicator * self.water_gamma[J_index[2], J_index[3]]
        protein_mediated = protein_indicator  * self.protein_gamma[J_index[2], J_index[3]]
        contact_energy = p.k_contact * np.array([direct, water_mediated, protein_mediated]) * sequence_mask_contact[np.newaxis, :, :, np.newaxis, np.newaxis]

        # Compute electrostatics
        if p.k_electrostatics!=0:
            self.sequence_cutoff=min(p.min_sequence_separation_electrostatics, p.min_sequence_separation_contact)
            self.distance_cutoff=None
            
            
            electrostatics_mask = frustration.compute_mask(self.distance_matrix, maximum_contact_distance=None, minimum_sequence_separation=p.min_sequence_separation_electrostatics, start_mask=self.start_mask)
            # ['A', 'R', 'N', 'D', 'C', 'Q', 'E', 'G', 'H', 'I', 'L', 'K', 'M', 'F', 'P', 'S', 'T', 'W', 'Y', 'V']
            charges = np.array([0, 1, 0, -1, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
            charges2 = charges[:,np.newaxis]*charges[np.newaxis,:]

            electrostatics_indicator = 1 / (self.distance_matrix + 1E-6) * np.exp(-self.distance_matrix / p.electrostatics_screening_length) * electrostatics_mask
            electrostatics_energy = -p.k_electrostatics * (charges2[np.newaxis,np.newaxis,:,:]*electrostatics_indicator[:,:,np.newaxis,np.newaxis])

            contact_energy = np.append(contact_energy, electrostatics_energy[np.newaxis,:,:,:,:], axis=0)
            if expose_indicator_functions:
                self.indicators.append(electrostatics_indicator)
                temp_gamma=0.5 * p.k_electrostatics * charges2[self.aa_map_awsem_x, self.aa_map_awsem_y]
                temp_gamma[0,:]=0
                temp_gamma[:,0]=0
                self.gamma_array.append(temp_gamma)
        else:
            self.sequence_cutoff=p.min_sequence_separation_contact
            self.distance_cutoff=p.distance_cutoff_contact
        self.mask = frustration.compute_mask(self.distance_matrix, maximum_contact_distance=self.distance_cutoff, minimum_sequence_separation = self.sequence_cutoff, start_mask=self.start_mask)

        self.contact_energy = contact_energy

        # Compute fast properties
        if self.stats_by_chain:
            aa_freq, aa_freq_by_chain = frustration.compute_aa_freq(self.sequence,
                                                    segment_aa_freq=self.stats_by_chain,start_mask=self.start_mask,new_AA="-ARNDCQEGHILKMFPSTWYV")
            aa_freq = aa_freq[1:] # cut off gap frequency
            aa_freq_by_chain = [chain_aa_freq[1:] for chain_aa_freq in aa_freq_by_chain] # cut off gap frequency
            self.aa_freq = aa_freq
            self.aa_freq_by_chain = aa_freq_by_chain
            contact_freq, contact_freq_by_chain = frustration.compute_contact_freq(self.sequence,
                                                    segment_aa_freq=self.stats_by_chain,start_mask=self.start_mask,new_AA="-ARNDCQEGHILKMFPSTWYV")
            contact_freq = contact_freq[1:,1:] # cut off gap frequency
            contact_freq_by_chain = [chain_contact_freq[1:,1:] for chain_contact_freq in contact_freq_by_chain] # cut off gap frequency
            self.contact_freq = contact_freq
            self.contact_freq_by_chain = contact_freq_by_chain
            #print(self.aa_freq_by_chain)
            #print(self.contact_freq_by_chain)
            #print(self.sequence)
            #print(len(self.sequence))
            #print(self.start_mask)
            #exit()
        else:
            self.aa_freq = frustration.compute_aa_freq(self.sequence,
                            segment_aa_freq=self.stats_by_chain,start_mask=self.start_mask)
            self.contact_freq = frustration.compute_contact_freq(self.sequence,
                                segment_aa_freq=self.stats_by_chain,start_mask=self.start_mask)
            self.aa_freq_by_chain = None
            self.contact_freq_by_chain = None

        self.potts_model = {}
        self.potts_model['h'] = burial_energy.sum(axis=-1)[:, self.aa_map_awsem_list]
        self.potts_model['J'] = contact_energy.sum(axis=0)[:, :, self.aa_map_awsem_x, self.aa_map_awsem_y]
        
        # Set the gap energy to zero
        self.potts_model['h'][:, 0] = 0
        self.potts_model['J'][:, :, 0, :] = 0
        self.potts_model['J'][:, :, :, 0] = 0
        self._native_energy=None

    def compute_configurational_decoy_statistics(self, n_decoys=4000,aa_freq=None):
        # ['A', 'R', 'N', 'D', 'C', 'Q', 'E', 'G', 'H', 'I', 'L', 'K', 'M', 'F', 'P', 'S', 'T', 'W', 'Y', 'V']
        _AA='ARNDCQEGHILKMFPSTWYV'
        if aa_freq is None:
            if self.stats_by_chain:
                N = self.N * 10 # see note below
                aa_freq = np.array(self.aa_freq_by_chain)
                probabilities = [aa_freq[i,:] / np.sum(aa_freq[i,:]) for i in range(aa_freq.shape[0])]
                #print(probabilities)
                try:
                    seq_index = [np.random.choice(a=aa_freq.shape[1], size=N, p=probabilities[i]) for i in range(aa_freq.shape[0])]
                except ValueError:
                    print("stats_by_chain seq_index issue")
                    #import pdb; pdb.set_trace()
                    raise
                # note there is no need to break seq_index into segments with sizes proportional to the length of the chain
                # in other words, it is fine if seq_index is "too big"
                # segment splitting aside, we have actually already made N "too big" by setting N=self.N*10 (see note below)
                #raise ValueError("Segment-wise statistics calculation requested but no start_mask was given")
            else: # assume we don't want to do different statistics for different subsegments
                seq_index = [np.array([_AA.find(aa) for aa in self.sequence])] # replace with seq_index = np.array(self.aa_freq)?
                N=self.N
        else:
            N=self.N*10 # i think we multiply by 10 because we're concerned about seq_index possibly being a bad 
                        # representation of the sequence by bad luck with our np.random.choice 
                        # but if this is an issue, why not just call np.random.choice with size=1 on the probabilities
                        # each time we a random identity? I guess it is kind of slow
            aa_freq = np.array(aa_freq) # axis 0: each subsegment (if requested, otherwise length is 1)
                                        # axis 1: amino acid type
            probabilities = [aa_freq[i,:] / np.sum(aa_freq[i,:]) for i in range(aa_freq.shape[0])]
            seq_index = [np.random.choice(a=aa_freq.shape[1], size=N, p=probabilities[i]) for i in range(aa_freq.shape[0])] # see note above on splitting N
        
        rho_b = np.expand_dims(self.rho_r, 1) #(n,1)
        rho1 = np.expand_dims(self.rho_r, 0) #(1,n)
        rho2 = np.expand_dims(self.rho_r, 1) #(n,1)
        sigma_water = 0.25 * (1 - np.tanh(self.eta_sigma * (rho1 - self.rho_0))) * (1 - np.tanh(self.eta_sigma * (rho2 - self.rho_0))) #(n,n)
        #sigma_protein = 1 - sigma_water #(n,n) we'll calculated this later
        charges = np.array([0, 1, 0, -1, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]) # for electrostatics
        distances = np.triu(self.distance_matrix)

        if self.stats_by_chain:
            # order by segment
            # the goal is for this function to work for segmented and unsegmented aa_freq/distance/rho distributions
            # (an unsegmented one is equivalent to a segmented one of length N)
            distances, sigma_water, sigma_protein, burial_indicator = self.chain_split(distances, sigma_water,rho_b)
            #Calculate other indicators, broken down by segment
            theta = [] # (num_segments,num_distances)    note num_distances is probably much greater than number of residues in the segment
            thetaII = [] # (num_segments,num_distances)  note num_distances is probably much greater than number of residues in the segment
            electrostatics_indicator = [] # (num_segments,num_distances) note num_distances is probably much greater than number of residues in the segment
            for counter in range(len(distances)):
                theta.append(0.25 * (1 + np.tanh(self.eta * (distances[counter] - self.r_min))) * (1 + np.tanh(self.eta * (self.r_max - distances[counter])))) 
                thetaII.append(0.25 * (1 + np.tanh(self.eta * (distances[counter] - self.r_minII))) * (1 + np.tanh(self.eta * (self.r_maxII - distances[counter])))) 
                electrostatics_indicator.append(np.exp(-distances[counter] / self.electrostatics_screening_length) / distances[counter])
        else:
            # compute indicator functions and enclose everything in a list so that we can use the same syntax
            # for segmented and unsegmented (meaning one segment for the entire system) systems
            distances = [distances[(distances<self.distance_cutoff_contact) & (distances>0)]]
            sigma_protein = 1 - sigma_water
            sigma_water = [sigma_water]
            sigma_protein = [sigma_protein]
            burial_indicator = [np.tanh(self.burial_kappa * (rho_b - self.burial_ro_min)) + np.tanh(self.burial_kappa * (self.burial_ro_max - rho_b))]
            theta = [0.25 * (1 + np.tanh(self.eta * (distances[0] - self.r_min))) * (1 + np.tanh(self.eta * (self.r_max - distances[0])))]
            thetaII = [0.25 * (1 + np.tanh(self.eta * (distances[0] - self.r_minII))) * (1 + np.tanh(self.eta * (self.r_maxII - distances[0])))]
            electrostatics_indicator = [np.exp(-distances[0] / self.electrostatics_screening_length) / distances[0]]

        decoy_energies=np.zeros((self.N,n_decoys)) # shape is (num_residues, num_decoys_per_segment)
        seg_start_res_idx = 0 # track start index of the current residue
        for segment_index in range(len(distances)):
            segment_distances = distances[segment_index]
            segment_theta = theta[segment_index]
            segment_thetaII = thetaII[segment_index]
            segment_burial_indicator = burial_indicator[segment_index]
            segment_sigma_water = sigma_water[segment_index]
            segment_sigma_protein = sigma_protein[segment_index]
            segment_electrostatics_indicator = electrostatics_indicator[segment_index]
            #print(f"printing: segment_electrostatics")
            #print(segment_electrostatics_indicator)
            #print(f"printing: segment distances")
            #print(segment_distances)
            assert segment_burial_indicator.shape[1] == 3, segment_burial_indicator.shape
            assert len(segment_distances.shape) # the selection operation applying the sequence separation and distance criteria should flatten it
            segment_N_small = segment_burial_indicator.shape[0]
            segment_N_big = N/self.N*segment_N_small # N/self.N tells us whether the factor we need to multiply segment_N_small by is 10 or 1
                                                     # (depending on whether aa_freq was passed to the function or not--see above)
            try:
                segment_seq_index = seq_index[segment_index]
            except IndexError:
                print(distances)
                raise

            for i in range(n_decoys): # we do the same number for each chain, so be careful. this could make the computation very long
                try:
                    c=np.random.randint(0,segment_distances.shape[0]) # pick a random residue's distance
                except ValueError:
                    #import pdb; pdb.set_trace()
                    print("segment_distances shape issue!")
                    print(segment_distances.shape)
                    raise
                n1=np.random.randint(0,segment_N_small) # pick a random residue's local density 
                n2=np.random.randint(0,segment_N_small) # pick another random residue's local density
                qi1=np.random.randint(0,segment_N_big) # pick a random residue 
                qi2=np.random.randint(0,segment_N_big) # pick another random residue
                try:
                    q1=segment_seq_index[qi1] # pick the identity of the random residue
                except IndexError:
                    print("qi1 not found in q1!")
                    print(distances)
                    print(seq_index)
                    print(segment_seq_index)
                    print(qi1)
                    print(seq_index)
                    print(len(seq_index))
                    raise
                q2=segment_seq_index[qi2] # pick the identity of the other random residue
                try:
                    burial_energy1 = (-0.5 * self.k_contact * self.burial_gamma[q1] * segment_burial_indicator[n1]).sum(axis=0)
                    burial_energy2 = (-0.5 * self.k_contact * self.burial_gamma[q2] * segment_burial_indicator[n2]).sum(axis=0)
                except IndexError as e:
                    #import pdb; pdb.set_trace()
                    print("indexing issue burial_energy1 burial_energy2")
                    raise
                
                direct = segment_theta[c] * self.direct_gamma[q1, q2] # direct interaction for random distance and amino acid pair
                water_mediated = segment_sigma_water[n1,n2] * segment_thetaII[c] * self.water_gamma[q1,q2] # water-mediated interaction for the same random pair and distance,
                                                                                                           # and also random local densities
                protein_mediated = segment_sigma_protein[n1,n2] * segment_thetaII[c] * self.protein_gamma[q1,q2] # same for protein-mediated
                contact_energy = -self.k_contact * (direct+water_mediated+protein_mediated)
                electrostatics_energy = self.k_electrostatics * segment_electrostatics_indicator[c]*charges[q1]*charges[q2] # same amino acid types and distance for electrostatics

                #decoy_energies[segment_index,i]=(burial_energy1+burial_energy2+contact_energy+electrostatics_energy)
                # every residue position in the current segment should get the same pair energy for this decoy
                decoy_energies[seg_start_res_idx:seg_start_res_idx+segment_N_small,i]=(burial_energy1+burial_energy2+contact_energy+electrostatics_energy)
        
            # increment our start residue index before proceeding to next segment
            seg_start_res_idx += segment_N_small
        #import pdb; pdb.set_trace()
        mean_decoy_energy = np.mean(decoy_energies, axis=1) # average over all decoys for each residue
        std_decoy_energy = np.std(decoy_energies,axis=1) # standard deviation of over all decoys for each residue
        return mean_decoy_energy, std_decoy_energy
    
    def chain_split(self, distances, sigma_water, rho_b):
        # break distances into a list for each segment
        distances_by_segment = []
        sigma_water_by_segment = []
        sigma_protein_by_segment = []
        burial_indicator = []
        segment_start_indices = np.where(np.array(self.start_mask)==1)[0] # np.where returns a numpy array wrapped in a tuple, so we have to unwrap
        for counter in range(len(segment_start_indices)):
            ij_start = segment_start_indices[counter]
            if counter != len(segment_start_indices)-1:
                ij_end = segment_start_indices[counter+1]
            else: # if we're on the last segment, the end index is just N, the number of residues in our system
                ij_end = len(self.start_mask)
            segment_block = distances[ij_start:ij_end,ij_start:ij_end] # taking block around diagonal, which represents interactions
                                                                       # within each subsegment
            distances_by_segment.append(segment_block[(segment_block<self.distance_cutoff_contact) & (segment_block>0)])
            # break sigma_water and sigma_protein into a list for each segment
            sigma_water_by_segment.append(sigma_water[ij_start:ij_end,ij_start:ij_end])
            sigma_protein_by_segment.append(1-sigma_water[ij_start:ij_end,ij_start:ij_end])
            burial_indicator.append(np.tanh(self.burial_kappa * (rho_b[ij_start:ij_end,:] - self.burial_ro_min)) + np.tanh(self.burial_kappa * (self.burial_ro_max - rho_b[ij_start:ij_end,:])))
        ## break sigma_water and sigma_protein into a list for each segment
        #sigma_water_by_segment = []
        #sigma_protein_by_segment = []
        #for counter in range(len(segment_start_indices)-1):
        #    ij_start = segment_start_indices[counter]
        #    ij_end = segment_start_indices[counter+1]
        #    segment_block = sigma_water[ij_start:ij_end,ij_start:ij_end] # taking block around diagonal, which represents interactions
        #                                                                 # within each subsegment
        #    sigma_water_by_segment.append(segment_block)
        #    sigma_protein_by_segment.append(1-segment_block)
        return distances_by_segment, sigma_water_by_segment, sigma_protein_by_segment, burial_indicator


    def compute_configurational_energies(self):
        _AA='ARNDCQEGHILKMFPSTWYV'
        seq_index = np.array([_AA.find(aa) for aa in self.sequence]) # this is fine for a multi chain system if sequence and structure are both fixed
        #distances = np.triu(self.distance_matrix)
        distances_indices = np.triu_indices(self.distance_matrix.shape[0], k=2) # IMPORTANT CHANGE TO MAKE IT MORE LIKE THE TCL SCRIPT!!!
        triu_mask = np.zeros(self.distance_matrix.shape,dtype=np.bool_)
        triu_mask[distances_indices] = True
        for index,bit in enumerate(self.start_mask):
            if bit==1 and index!=0: # if index is 0, then index-1 is -1, and we don't want to set that to 1
                assert triu_mask[index,index-1] == 0
                assert triu_mask[index-1,index] == 0
                triu_mask[index,index-1] == 1 # pairs crossing chains should be considered, even if they're nearest neighbors in sequence
                triu_mask[index-1,index] == 1 # pairs crossing chains should be considered, even if they're nearest neighbors in sequence
        distances = self.distance_matrix * triu_mask
        distances = distances[(distances<self.distance_cutoff_contact) & (distances>0) & (distances>self.min_contact_distance)] # use 3.5 TO MAKE IT MORE LIKE THE TCL SCRIPT!!!
        n_contacts=len(distances)

        n = self.distance_matrix.shape[0]  # Assuming self.distance_matrix is defined and square
        #tri_upper_indices = np.triu_indices(n, k=1)  # k=1 excludes the diagonal
        tri_upper_indices = np.triu_indices(n, k=2)  # k=1 excludes the diagonal #######################IMPORTANT CHANGE TO MAKE IT MORE LIKE THE TCL SCRIPT!!!
        valid_pairs = (self.distance_matrix[tri_upper_indices] < self.distance_cutoff_contact)\
                      & (self.distance_matrix[tri_upper_indices] > self.min_contact_distance) ######################3 IMPORTANT CHANGE TO MAKE IT MORE LIKE THE TCL SCRIPT!!!!!!!1
        indices1,indices2 = (tri_upper_indices[0][valid_pairs], tri_upper_indices[1][valid_pairs])
        self.config_indices1 = indices1
        self.config_indices2 = indices2
        # for n1,n2,c in zip(indices1,indices2,range(n_contacts)):
        #     assert self.distance_matrix[n1,n2] == distances[c]
        
        rho_b = np.expand_dims(self.rho_r, 1) #(n,1)
        rho1 = np.expand_dims(self.rho_r, 0) #(1,n)
        rho2 = np.expand_dims(self.rho_r, 1) #(n,1)

        sigma_water = 0.25 * (1 - np.tanh(self.eta_sigma * (rho1 - self.rho_0))) * (1 - np.tanh(self.eta_sigma * (rho2 - self.rho_0))) #(n,n)
        sigma_protein = 1 - sigma_water #(n,n)

        #Calculate theta and indicators
        theta = 0.25 * (1 + np.tanh(self.eta * (distances - self.r_min))) * (1 + np.tanh(self.eta * (self.r_max - distances))) # (c,)
        thetaII = 0.25 * (1 + np.tanh(self.eta * (distances - self.r_minII))) * (1 + np.tanh(self.eta * (self.r_maxII - distances))) #(c,)
        burial_indicator = np.tanh(self.burial_kappa * (rho_b - self.burial_ro_min)) + np.tanh(self.burial_kappa * (self.burial_ro_max - rho_b)) #(n,3)
           
        charges = np.array([0, 1, 0, -1, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
        electrostatics_indicator = np.exp(-distances / self.electrostatics_screening_length) / distances

        # decoy_data_columns=['decoy_i','i_resno','j_resno','ires_type','jres_type','aa1','aa2','rij','rho_i','rho_j','water_energy','burial_energy_i','burial_energy_j','electrostatic_energy','total_energies']
        # decoy_data=[]
        configurational_energies=np.zeros((n,n))
        for c in range(n_contacts):
            n1=indices1[c]
            n2=indices2[c]
            q1=seq_index[n1]
            q2=seq_index[n2]

            burial_energy1 = (-0.5 * self.k_contact * self.burial_gamma[q1] * burial_indicator[n1]).sum(axis=0)
            burial_energy2 = (-0.5 * self.k_contact * self.burial_gamma[q2] * burial_indicator[n2]).sum(axis=0)
            
            direct = theta[c] * self.direct_gamma[q1, q2]
            water_mediated = sigma_water[n1,n2] * thetaII[c] * self.water_gamma[q1,q2]
            protein_mediated = sigma_protein[n1,n2] * thetaII[c] * self.protein_gamma[q1,q2]
            contact_energy = -self.k_contact * (direct+water_mediated+protein_mediated)
            electrostatics_energy = self.k_electrostatics * electrostatics_indicator[c]*charges[q1]*charges[q2]

            energy=(burial_energy1+burial_energy2+contact_energy+electrostatics_energy)
            configurational_energies[n1,n2]=energy
            configurational_energies[n2,n1]=energy
            # decoy_data+=[[c, n1, n2, q1, q2, _AA[q1],_AA[q2], distances[c], self.rho_r[n1], self.rho_r[n2], contact_energy/4.184, burial_energy1/4.184, burial_energy2/4.184, electrostatics_energy/4.184, energy/4.184]]
        # import pandas as pd
        return configurational_energies #, pd.DataFrame(decoy_data, columns=decoy_data_columns)
    
    def configurational_frustration(self,aa_freq=None, correction=0, n_decoys=4000):
        mean_decoy_energy, std_decoy_energy = self.compute_configurational_decoy_statistics(n_decoys=n_decoys,aa_freq=aa_freq)
        assert len(mean_decoy_energy.shape)==1, mean_decoy_energy
        assert len(std_decoy_energy.shape)==1, std_decoy_energy
        assert mean_decoy_energy.shape == std_decoy_energy.shape, (mean_decoy_energy.shape,std_decoy_energy.shape)
        corrected_mean = np.zeros((mean_decoy_energy.shape[0],mean_decoy_energy.shape[0]))
        corrected_std = np.zeros((mean_decoy_energy.shape[0],mean_decoy_energy.shape[0]))
        for i in range(mean_decoy_energy.shape[0]):
            for j in range(mean_decoy_energy.shape[0]):
                #print(mean_decoy_energy[i])
                #print(mean_decoy_energy[j])
                corrected_mean[i,j] = (mean_decoy_energy[i]+mean_decoy_energy[j])/2
                #corrected_std[i,j] = np.linalg.norm([std_decoy_energy[i],std_decoy_energy[j]])/np.sqrt(2)
                corrected_std[i,j] = (std_decoy_energy[i]+std_decoy_energy[j])/2
        return -(self.compute_configurational_energies()-corrected_mean)/(corrected_std+correction) 
        # for multiple segments, should make this mean and variance a function of the means and variances of the segments of the pair
        # not sure exactly how that should be done